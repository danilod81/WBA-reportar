<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Reporte de Problema de mantenimiento</title>
  <style>
    :root{ --bg:#f6f7fb; --card:#fff; --text:#111827; --muted:#6b7280; --primary:#2563eb; --border:#e5e7eb; }
    *{ box-sizing:border-box }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--text); line-height:1.5; }
    .container{ max-width:680px; margin:0 auto; padding:20px 16px 40px }
    h1{ text-align:center; font-size:clamp(1.25rem,4.8vw,1.8rem); font-weight:800; margin:6px 0 2px }
    .sub{ text-align:center; margin:2px 0 16px; color:var(--muted); font-size:.98rem; min-height:1.4em }
    .card{ background:var(--card); border:1px solid var(--border); border-radius:16px; padding:20px }
    label{ display:block; margin:18px 0 8px; font-weight:600 }
    textarea{ width:100%; padding:14px; border:1px solid var(--border); border-radius:12px; font-size:1rem; min-height:120px; resize:vertical }
    textarea:focus{ outline:none; border-color:#9ec1ff; box-shadow:0 0 0 3px rgba(37,99,235,.15) }
    .cam{ display:grid; gap:10px }
    video{ width:100%; border-radius:12px; background:#000 }
    .row{ display:flex; gap:10px; flex-wrap:wrap }
    button{ appearance:none; border:0; border-radius:12px; padding:14px 16px; background:var(--primary); color:#fff; font-weight:600; cursor:pointer }
    .secondary{ background:#111827 }
    .thumbs{ display:flex; gap:8px; flex-wrap:wrap }
    .thumb{ position:relative }
    .thumb img{ width:90px; height:90px; object-fit:cover; border-radius:10px; border:1px solid var(--border) }
    .thumb button{ position:absolute; top:4px; right:4px; border-radius:8px; padding:4px 6px; font-size:.8rem; background:#ef4444 }
    .status{ margin-top:10px; color:var(--muted); text-align:center; font-size:.95rem; min-height:1.5em }
    .error{ color:#b91c1c }
    .ok{ color:#065f46 }
    .hidden{ display:none }
    .file-fallback{ color:var(--muted); font-size:.9rem }
    input[type=file]{ display:block; width:100% }
    .busy{ opacity:.7; pointer-events:none }

    /* Aviso de red */
    .net{ position:sticky; top:0; padding:8px 12px; border-radius:10px; background:#fee2e2; color:#991b1b; text-align:center; margin:6px auto 12px }
    .net.ok{ background:#dcfce7; color:#065f46 }
  </style>
</head>
<body>
  <div class="container">
    <h1>üîß Reporte de Problema de mantenimiento</h1>
    <div id="direccionDepto" class="sub">Direcci√≥n del departamento</div>
    <div id="net" class="net hidden">Sin conexi√≥n</div>

    <div class="card">
      <!-- Enviamos con fetch para adjuntar Blobs -->
      <form id="form" novalidate>
        <input type="hidden" id="departamento" name="departamento" />
        <input type="hidden" id="reporta" name="reporta" />

        <label for="descripcion">Detalle del problema *</label>
        <textarea id="descripcion" name="descripcion" placeholder="Contanos qu√© pas√≥, d√≥nde y desde cu√°ndo‚Ä¶" required></textarea>

        <label>Fotos (sacadas ahora) *</label>

        <!-- UI de c√°mara -->
        <div id="cameraBox" class="cam">
          <video id="preview" playsinline autoplay muted></video>
          <div class="row">
            <button type="button" id="btnShot">üì∏ Tomar foto</button>
            <button type="button" id="btnFlip">üîÑ Cambiar c√°mara</button>
          </div>
          <div id="thumbs" class="thumbs"></div>
          <div class="file-fallback hidden" id="fallbackNote">No pudimos acceder a la c√°mara. Us√° este campo (intentar√° abrir la c√°mara del dispositivo):</div>
          <!-- Fallback: intenta c√°mara del SO; algunos navegadores permiten galer√≠a -->
          <input id="fallbackInput" class="hidden" type="file" name="media[]" accept="image/*" capture="environment" multiple>
        </div>

        <div class="row" style="margin-top:16px">
          <button id="submitBtn" class="secondary" type="submit">Enviar reporte</button>
        </div>
        <div id="status" class="status" role="status" aria-live="polite"></div>
      </form>
    </div>
  </div>

  <script>
    // ========================
    // CONFIG & UTILIDADES
    // ========================
    const qs = new URLSearchParams(location.search);
    const depQS = (qs.get('departamento') || '').trim();
    const repQS = (qs.get('reporta') || '').trim();
    const WEBHOOK_URL = 'https://optimaltm.app.n8n.cloud/webhook/wba-reporte-mantenimiento';

    const netEl = document.getElementById('net');
    const statusEl = document.getElementById('status');
    const submitBtn = document.getElementById('submitBtn');

    if (depQS) {
      document.getElementById('departamento').value = depQS;
      document.getElementById('direccionDepto').textContent = depQS;
    }
    if (repQS) document.getElementById('reporta').value = repQS;

    function enc(v){ return encodeURIComponent((v ?? '').toString()); }
    function ok(msg){ statusEl.innerHTML = `<span class="ok">${msg}</span>`; }
    function err(msg){ statusEl.innerHTML = `<span class="error">${msg}</span>`; }

    // ========================
    // C√ÅMARA
    // ========================
    const video = document.getElementById('preview');
    const btnShot = document.getElementById('btnShot');
    const btnFlip = document.getElementById('btnFlip');
    const thumbs = document.getElementById('thumbs');
    const fallbackInput = document.getElementById('fallbackInput');
    const fallbackNote = document.getElementById('fallbackNote');

    const MB = 1024 * 1024;
    const MAX_FILES = 10;
    const MAX_FILE_MB = 20;

    let stream = null;
    let usingEnv = true; // c√°mara trasera por defecto
    const shots = [];    // { blob, url }

    async function startCamera() {
      try {
        if (stream) stream.getTracks().forEach(t => t.stop());
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: usingEnv ? { exact: 'environment' } : 'user' },
          audio: false
        });
        video.srcObject = stream;
        video.classList.remove('hidden');
        fallbackInput.classList.add('hidden');
        fallbackNote.classList.add('hidden');
      } catch (e) {
        video.classList.add('hidden');
        fallbackNote.classList.remove('hidden');
        fallbackInput.classList.remove('hidden');
      }
    }

    function addThumb(blob) {
      const url = URL.createObjectURL(blob);
      shots.push({ blob, url });
      const div = document.createElement('div');
      div.className = 'thumb';
      div.innerHTML = `<img src="${url}" alt="foto"><button type="button">‚úï</button>`;
      div.querySelector('button').onclick = () => {
        const i = shots.findIndex(s => s.url === url);
        if (i >= 0) { URL.revokeObjectURL(shots[i].url); shots.splice(i,1); }
        div.remove();
      };
      thumbs.appendChild(div);
    }

    btnShot.addEventListener('click', async () => {
      statusEl.textContent = '';
      if (shots.length >= MAX_FILES) return err(`M√°ximo ${MAX_FILES} fotos.`);
      const rect = video.getBoundingClientRect();
      const w = video.videoWidth || rect.width;
      const h = video.videoHeight || rect.height;
      const canvas = Object.assign(document.createElement('canvas'), { width: w, height: h });
      canvas.getContext('2d').drawImage(video, 0, 0, w, h);
      const blob = await new Promise(r => canvas.toBlob(r, 'image/jpeg', 0.92));
      if (!blob) return err('No se pudo capturar la foto.');
      if (blob.size > MAX_FILE_MB * MB) return err(`La foto supera ${MAX_FILE_MB} MB.`);
      addThumb(blob);
    });

    btnFlip.addEventListener('click', async () => {
      usingEnv = !usingEnv;
      await startCamera();
    });

    if (navigator.mediaDevices?.getUserMedia) startCamera();
    else { video.classList.add('hidden'); fallbackNote.classList.remove('hidden'); fallbackInput.classList.remove('hidden'); }

    // ========================
    // INDEXEDDB (borrador + cola)
    // ========================
    const DB_NAME = 'wba-reporte-mantenimiento';
    const DB_VERSION = 1;
    let dbPromise = null;

    function openDB(){
      if (dbPromise) return dbPromise;
      dbPromise = new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onupgradeneeded = (e) => {
          const db = req.result;
          if (!db.objectStoreNames.contains('draft')) db.createObjectStore('draft', { keyPath: 'id' });
          if (!db.objectStoreNames.contains('queue')) db.createObjectStore('queue', { keyPath: 'id', autoIncrement: true });
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
      return dbPromise;
    }

    async function dbPut(store, value){ const db = await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readwrite'); tx.objectStore(store).put(value); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }
    async function dbGet(store, key){ const db = await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readonly'); const req=tx.objectStore(store).get(key); req.onsuccess=()=>res(req.result||null); req.onerror=()=>rej(req.error); }); }
    async function dbGetAll(store){ const db = await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readonly'); const req=tx.objectStore(store).getAll(); req.onsuccess=()=>res(req.result||[]); req.onerror=()=>rej(req.error); }); }
    async function dbDelete(store, key){ const db = await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readwrite'); tx.objectStore(store).delete(key); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }

    // Guarda un borrador (sobrescribe siempre id='current')
    async function saveDraft(payload){
      await dbPut('draft', { id:'current', ts:Date.now(), ...payload });
    }
    // Carga borrador y lo pinta en UI
    async function restoreDraftIfEmpty(){
      const d = await dbGet('draft','current');
      if (!d) return;
      const descEl = document.getElementById('descripcion');
      if (!descEl.value) descEl.value = d.descripcion || '';
      if (shots.length === 0 && Array.isArray(d.files)) {
        d.files.forEach(f => addThumb(f.blob));
      }
    }
    // Encola un reporte para reintentar
    async function enqueue(payload){
      await dbPut('queue', payload);
    }

    // Toma la cola y la intenta enviar (se frena si falla red)
    async function flushQueue(){
      if (!navigator.onLine) return;
      const items = await dbGetAll('queue');
      if (!items.length) return;
      let okCount = 0;

      for (const item of items){
        try{
          const sent = await sendPayload(item);
          if (sent.ok){
            await dbDelete('queue', item.id);
            okCount++;
          } else {
            // error de aplicaci√≥n: dejamos en cola y paramos
            break;
          }
        }catch{
          // error de red/timeout: dejamos en cola y paramos
          break;
        }
      }
      if (okCount > 0) ok(`Se enviaron ${okCount} reporte(s) pendientes.`);
    }

    // ========================
    // RED: indicador y eventos
    // ========================
    function updateNet(){
      if (navigator.onLine){
        netEl.textContent = 'Conectado';
        netEl.classList.remove('hidden');
        netEl.classList.add('ok');
        setTimeout(()=>netEl.classList.add('hidden'), 1200);
        flushQueue(); // intenta enviar pendientes
      } else {
        netEl.textContent = 'Sin conexi√≥n ‚Äî pod√©s guardar y lo enviamos cuando vuelva internet';
        netEl.classList.remove('ok','hidden');
      }
    }
    window.addEventListener('online', updateNet);
    window.addEventListener('offline', updateNet);
    updateNet();

    // ========================
    // ARMAR PAYLOAD + ENV√çO
    // ========================
    function gatherFiles(){
      // devuelve array [{name, type, blob}]
      const out = [];
      if (!fallbackInput.classList.contains('hidden')){
        const files = Array.from(fallbackInput.files || []);
        for (const f of files){ out.push({ name: f.name, type: f.type, blob: f }); }
      } else {
        for (let i=0;i<shots.length;i++){
          const b = shots[i].blob;
          out.push({ name:`foto-${i+1}.jpg`, type: b.type || 'image/jpeg', blob: b });
        }
      }
      return out;
    }

    function buildPayload(){
      const desc = (document.getElementById('descripcion').value || '').trim();
      return {
        departamento: depQS,
        reporta: repQS,
        descripcion: desc,
        files: gatherFiles(), // blobs
      };
    }

    async function sendPayload(payload){
      // arma FormData y hace fetch; retorna {ok, redirect?}
      const fd = new FormData();
      fd.append('departamento', payload.departamento);
      fd.append('reporta', payload.reporta);
      fd.append('descripcion', payload.descripcion);
      for (const f of payload.files) fd.append('media[]', f.blob, f.name);

      // timeout contra conexiones colgadas
      const controller = new AbortController();
      const to = setTimeout(()=>controller.abort(), 15000);

      try{
        const res = await fetch(WEBHOOK_URL, { method:'POST', body: fd, signal: controller.signal });
        clearTimeout(to);
        const text = await res.text().catch(()=> '');
        let data = null; try{ data = JSON.parse(text); } catch{}
        if (!res.ok) throw new Error(data?.message || text || `HTTP ${res.status} ${res.statusText}`);
        return { ok: !!data?.ok, redirect: data?.redirect || null };
      }catch(e){
        clearTimeout(to);
        // si es error de red/timeout => reintentar luego
        if (!navigator.onLine || e.name === 'AbortError' || /Failed to fetch|NetworkError/i.test(String(e.message))) {
          throw e; // tratamos como no env√≠o por red
        }
        // errores 4xx/5xx l√≥gicos
        return { ok:false };
      }
    }

    // ========================
    // SUBMIT
    // ========================
    document.getElementById('form').addEventListener('submit', async (e) => {
      e.preventDefault();
      statusEl.classList.remove('error','ok');

      const desc = (document.getElementById('descripcion').value || '').trim();
      if (!depQS)  return err('Falta ‚Äúdepartamento‚Äù.');
      if (!repQS)  return err('Falta ‚Äúreporta‚Äù.');
      if (!desc)   return err('Complet√° la descripci√≥n.');

      const payload = buildPayload();

      // validaci√≥n de al menos una imagen
      if (!payload.files.length) return err('Adjunt√° al menos una foto.');

      submitBtn.classList.add('busy');
      statusEl.textContent = 'Enviando‚Ä¶';

      // Si no hay internet: guardamos y encolamos
      if (!navigator.onLine){
        await saveDraft(payload);
        await enqueue(payload);
        ok('Sin conexi√≥n: guardamos el reporte para enviarlo autom√°ticamente cuando vuelva internet.');
        submitBtn.classList.remove('busy');
        return;
      }

      // Intento online
      try{
        const sent = await sendPayload(payload);
        if (sent.ok && sent.redirect) {
          // limpieza de borrador si coincide
          await dbPut('draft',{ id:'current', ts:Date.now() }); // vac√≠o
          window.location.href = sent.redirect;
          return;
        }
        // si no hubo redirect/ok, encolamos para reintentar
        await saveDraft(payload);
        await enqueue(payload);
        err('No pudimos confirmar el env√≠o. Lo guardamos y reintentaremos autom√°ticamente.');
      }catch(e){
        // error de red: guardamos y encolamos
        await saveDraft(payload);
        await enqueue(payload);
        err('No hay conexi√≥n o la red est√° inestable. Guardamos el reporte y lo enviaremos autom√°ticamente.');
      }finally{
        submitBtn.classList.remove('busy');
      }
    });

    // ========================
    // AL INICIAR: restaurar borrador y flush cola
    // ========================
    restoreDraftIfEmpty();
    flushQueue();
  </script>
</body>
</html>
